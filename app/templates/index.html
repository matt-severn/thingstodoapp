<!DOCTYPE html>
<html>
<head>
  <title>Date Map</title>
  <script src="https://maps.googleapis.com/maps/api/js?key={{ google_api_key }}"></script>
<link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
  <div id="sidebar">
<h1 style="font-family: Dancing Script, Papyrus, fantasy; font-weight: 100; font-size: 30px; color: darkred;">üíñ Date Ideas üíñ</h1>
    <form id="add-item-form">
      <input type="text" name="title" placeholder="Title" required>
      <input type="text" name="description" placeholder="Description"></input>
      <input type="text" name="location" placeholder="Location" required>
      <input type="number" name="cost" placeholder="Estimated cost (¬£)">
      <input type="text" name="tags" placeholder="Tags (comma separated)">
      <button type="submit">Add Date Idea</button>
    </form>
    <form id="edit-item-form" style="display:none;">
      <input type="hidden" name="index">
      <input type="text" name="title" placeholder="Title" required>
      <textarea name="description" placeholder="Description"></textarea>
      <input type="text" name="location" placeholder="Location" required>
      <input type="number" name="cost" placeholder="Estimated cost (¬£)">
      <input type="text" name="tags" placeholder="Tags (comma separated)">
      <button type="submit">Save Changes</button>
      <button type="button" onclick="cancelEdit()">Cancel</button>
    </form>
    <h2>Filters</h2>
    <div id="progress-counter">0/0 completed</div>
    <div id="filters">
  <label>
    <input type="checkbox" id="show-completed" checked> Show completed items
  </label>
  <br>
  <input type="text" id="search-input" placeholder="Search for a cute date...">
  <select id="tag-filter">
    <option value="">All Tags</option>
    <!-- Tags will be populated dynamically -->
  </select>
</div>
    <div id="items-list"></div>
    
  </div>
  <div id="map"></div>
  
  <script>
    let allTags = new Set();
    let currentSearchTerm = "";
    let currentTagFilter = "";
    let showCompleted = true;
    let map;
    let markers = [];
    let currentEditIndex = null;
    let currentItems = [];

    async function initMap() {
      const center = { lat: 51.5074, lng: -0.1278 }; // London
      map = new google.maps.Map(document.getElementById("map"), {
        zoom: 12,
        center: center,
      });

      await fetchItemsAndRender();
    }

    function extractAllTags(items) {
  const tags = new Set();
  items.forEach(item => {
    if (item.tags) {
      item.tags.forEach(tag => {
        if (tag && tag.trim() !== "") {
          tags.add(tag.trim());
        }
      });
    }
  });
  return Array.from(tags).sort();
}

function populateTagFilter(tags) {
  const select = document.getElementById('tag-filter');
  select.innerHTML = '<option value="">All Tags</option>';
  
  tags.forEach(tag => {
    const option = document.createElement('option');
    option.value = tag;
    option.textContent = tag;
    select.appendChild(option);
  });
}

function filterItems(items, searchTerm, tagFilter) {
  const lowerSearchTerm = searchTerm.toLowerCase().trim();
  
  return items.filter(item => {
    // Tag filter
    if (tagFilter && (!item.tags || !item.tags.includes(tagFilter))) {
      return false;
    }
    
    // Search term filter
    if (lowerSearchTerm) {
      const inTitle = item.title && item.title.toLowerCase().includes(lowerSearchTerm);
      const inDescription = item.description && 
                            item.description.toLowerCase().includes(lowerSearchTerm);
      
      const inTags = item.tags && 
                    item.tags.some(tag => tag.toLowerCase().includes(lowerSearchTerm));
      
      return inDescription || inTags || inTitle;
    }
    
    return true;
  });
}

function updateFilters() {
  renderItemsList();
}

    function createMarkers(items) {
      // Clear existing markers
      markers.forEach(marker => marker.setMap(null));
      markers = [];

      items.forEach((item, index) => {
        const marker = new google.maps.Marker({
          position: item.coords,
          map: map,
          title: item.title,
          icon: {
            path: google.maps.SymbolPath.BACKWARD_CLOSED_ARROW,
            fillColor: item.completed ? '#0F0' : '#F00',
            fillOpacity: 0.99,
            strokeWeight: 1,
            strokeColor: '#FFF',
            scale: 7
          }
        });

        const infowindow = new google.maps.InfoWindow({
          content: `
            <div>
              <strong>${item.title}</strong><br/>
              ${item.description}<br/>
              Cost: ¬£${item.cost}<br/>
              Tags: ${item.tags.join(', ')}<br/>
              Completed: ${item.completed ? '‚úÖ' : '‚ùå'}<br/>
              <button onclick="toggleCompleted(${index})">Toggle Completed</button>
              <button onclick="editItem(${index})">Edit</button>
              <button onclick="deleteItem(${index})">Delete</button>
            </div>`
        });

        marker.addListener('click', () => {
          infowindow.open(map, marker);
        });

        markers.push(marker);
      });
    }

    function renderItemsList() {
  // Apply filters to current items
  let itemsToRender = [...currentItems];
  
  // Apply search and tag filters
  itemsToRender = filterItems(itemsToRender, currentSearchTerm, currentTagFilter);
  
  // Apply showCompleted filter
  if (!showCompleted) {
    itemsToRender = itemsToRender.filter(item => !item.completed);
  }
  
  // Sort: incomplete first, completed last
  itemsToRender.sort((a, b) => {
    if (a.completed && !b.completed) return 1;
    if (!a.completed && b.completed) return -1;
    return 0;
  });
  
  const container = document.getElementById('items-list');
  container.innerHTML = itemsToRender.map(item => {
    const originalIndex = currentItems.findIndex(i => i.title === item.title);
    
    return `
    <div class="item ${item.completed ? 'completed' : ''}" data-id="${originalIndex}">
      <h3>${item.title}</h3>
      <p>${item.description}</p>
      <p>Location: ${item.location}</p>
      <p>Cost: ¬£${item.cost}</p>
      <p>Tags: ${item.tags.join(', ')}</p>
      
      
${item.completed ? `
    <div class="completion-details">
        <p>Completed on: ${item.completed_date}</p>
        ${item.rating ? `<p>Rating: ${item.rating}/10</p>` : ''}
        ${item.notes ? `<p>Notes: ${item.notes}</p>` : ''}  <!-- Add notes display -->
    </div>
` : ''}
      
      <button onclick="toggleCompleted(${originalIndex})">
        ${item.completed ? 'Mark Incomplete' : 'Mark Complete'}
      </button>
      <button onclick="editItem(${originalIndex})">Edit</button>
      <button onclick="deleteItem(${originalIndex})">Delete</button>
    </div>
  `}).join('');

  updateProgressCounter(currentItems);
}

async function fetchItemsAndRender() {
  const res = await fetch('/api/items');
  const items = await res.json();
  currentItems = items;
  
  // Update tags if needed
  const newTags = extractAllTags(items);
  if (newTags.length !== allTags.length || newTags.some((t, i) => t !== allTags[i])) {
    allTags = newTags;
    populateTagFilter(allTags);
  }
  
  // Create markers for all items
  createMarkers(items);
  
  // Render the filtered list
  renderItemsList();
}

async function toggleCompleted(index) {
    if (!currentItems[index]) return;
    
    if (!currentItems[index].completed) {
        let rating;
        while (true) {
            rating = prompt('Rate this date (1-10):');
            if (rating === null) return; // User cancelled
            rating = parseInt(rating);
            if (!isNaN(rating) && rating >= 1 && rating <= 10) break;
            alert('Please enter a number between 1 and 10');
        }
        
        // Add prompt for notes
        const notes = prompt('Add any notes from your date:');
        
        await fetch(`/api/items/${index}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                completed: true,
                rating: rating,
                completed_date: new Date().toISOString().split('T')[0],
                notes: notes || ""  // Add notes field
            })
        });
    } else {
        await fetch(`/api/items/${index}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                completed: false,
                rating: null,
                completed_date: null,
                notes: null  // Clear notes when toggling back
            })
        });
    }
    await fetchItemsAndRender();
}

    async function deleteItem(index) {
      if (confirm('Are you sure you want to delete this item?')) {
        await fetch(`/api/items/${index}`, { method: 'DELETE' });
        await fetchItemsAndRender();
      }
    }

    document.getElementById('add-item-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const formData = new FormData(e.target);
      const tags = formData.get('tags').split(',').map(tag => tag.trim());
      
      const itemData = {
        title: formData.get('title'),
        description: formData.get('description'),
        location: formData.get('location'),
        cost: formData.get('cost') || 0,
        tags: tags
      };

      await fetch('/api/items', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(itemData)
      });

      e.target.reset();
      await fetchItemsAndRender();
    });

    function editItem(index) {
      const item = currentItems[index];
      const form = document.getElementById('edit-item-form');
      form.style.display = 'block';
      form.title.value = item.title;
      form.description.value = item.description;
      form.location.value = item.location;
      form.cost.value = item.cost;
      form.tags.value = item.tags.join(', ');
      form.index.value = index;
      window.scrollTo(0, 0);
    }

    function cancelEdit() {
      document.getElementById('edit-item-form').style.display = 'none';
    }

    function toggleCompletedFilter() {
  showCompleted = !showCompleted;
  document.getElementById('show-completed').checked = showCompleted;
  renderItemsList();
}

function updateProgressCounter(items) {
  const total = items.length;
  const completed = items.filter(item => item.completed).length;
  const percentage = total > 0 ? Math.round((completed/total)*100) : 0;
  document.getElementById('progress-counter').textContent = 
    `${completed}/${total} completed (${percentage}%)`;
}

    document.getElementById('show-completed').addEventListener('change', () => {
    toggleCompletedFilter();
});

    document.getElementById('edit-item-form').addEventListener('submit', async (e) => {
    e.preventDefault();
    const formData = new FormData(e.target);
    const index = formData.get('index');
    const tags = formData.get('tags').split(',').map(tag => tag.trim());
    
    const itemData = {
        title: formData.get('title'),
        description: formData.get('description'),
        location: formData.get('location'),
        cost: formData.get('cost') || 0,
        tags: tags
    };
    
    await fetch(`/api/items/${index}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(itemData)
    });
    
    e.target.style.display = 'none';
    await fetchItemsAndRender();
});

// Add event listeners for filters
document.getElementById('search-input').addEventListener('input', (e) => {
  currentSearchTerm = e.target.value;
  updateFilters();
});

document.getElementById('tag-filter').addEventListener('change', (e) => {
  currentTagFilter = e.target.value;
  updateFilters();
});

    window.toggleCompleted = toggleCompleted;
    window.deleteItem = deleteItem;
    window.editItem = editItem;
    window.cancelEdit = cancelEdit;
    window.onload = initMap;
  </script>
</body>
</html>